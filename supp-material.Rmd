---
title: "Supplementary material - Woody Biomass Stocks and Fluxes in the Barro Colorado Island 50 ha Plot"
author:
  - Camille Piponiot:
      email: camille.piponiot-laroche@cirad.fr
      institute: [fs]
  - Helene C. Muller-Landau:
      institute: [stri] 

institute:
  - fs: Cirad, Université de Montpellier, UR Forests and Societies, 34980 Montferrier-sur-Lez, France
  - stri: Forest Global Earth Observatory, Smithsonian Tropical Research Institute, Apartado Postal 0843-03092, Panamá, Republic of Panamá

output: 
  html_document:
    code_folding: hide
    pandoc_args:
      - '--lua-filter=common/scholarly-metadata.lua'
      - '--lua-filter=common/author-info-blocks.lua'
bibliography: references.bib
csl: common/new-phytologist.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, results = "hide")
```

# Detailed methods and codes

Some R packages are used in the codes, and must be installed on the computer beforehand. The following code automatically installs the missing packages. 

```{r install-packages}
# list of package dependencies
req_packages <- c("rdryad", "data.table", "utils", "truncnorm", "openxlsx", "docxtractr")

# packages that are not yet installed on the computer
ins_packages <-  req_packages[!(req_packages %in% rownames(installed.packages()))]

# install missing packages
if (length(ins_packages) > 0) 
  install.packages(ins_packages)
```

## Get census data ready

Census data was downloaded from an online Dryad repository [@Condit2019]. Census data contain 8 censuses of the Barro Colorado 50-ha plot, from 1981 to 2015, of all stems from 1 cm of diameter at breast height (`dbh`).

```{r download-bci-data}
dryad_data_path <- rdryad::dryad_download("10.15146/5xcp-0d46")

# unzip files
zip_files <- grep("\\.zip", dryad_data_path$`10.15146/5xcp-0d46`, value = TRUE)
zip_folders <- sapply(zip_files, function(dir) {
  name <- gsub("\\.zip", "", data.table::last(strsplit(dir, '/')[[1]]))
  utils::unzip(dir, exdir = name)
})
```

The first census is usually removed from biomass analyses because diameter of buttressed trees with irregular trunks were measured around buttresses at breast height, thus creating a strong bias in the biomass estimations. 

```{r load-and-remove-first-census}
# 1. list census files, except first census (which has problematic measurements
# of large trees)
bci_stem <- list.files("bci.stem")[-1]

# 2. load census files as list
census_list <- lapply(bci_stem, function(name) {
  load(paste0("bci.stem/", name)); get(strsplit(name, "\\.rda")[[1]][1])
})

# 3. add census number information as list names
names(census_list) <- data.table::tstrsplit(bci_stem, "\\.")[[2]]

# 4. compile as one data table
df_stem <- data.table::rbindlist(census_list, fill = TRUE, idcol = "censusID")
```

Each individual stem was identified to the lowest taxonomic level possible (100% genus; 98% species; 3% subspecies) and was given a species code (`sp`). An independent species table (`bci.spptable`) contains all the taxonomic detail for each species code (species Latin name, family, subspecies when relevant, wood specific gravity).

```{r add-species-info}
load(grep("spp", dryad_data_path$`10.15146/5xcp-0d46`, value = TRUE))

df_stem <- merge(df_stem, bci.spptable, by = "sp", all.x = TRUE) 
```

The exact date of measurement was recorded in the `ExactDate` column; the year of each census was estimated as the median of all measurement years for this census. 

```{r add-census-year}
df_stem[, year := as.numeric(data.table::tstrsplit(ExactDate, "-")[[1]])]
df_stem[, census_year := median(year, na.rm = TRUE), .(censusID)]
```

Only stems above 10 mm DBH and alive were kept in the analysis.  

```{r remove-smallest-stems}
df_stem <- subset(df_stem, dbh >= 10 & grepl("A", status))
```

Individuals of strangler fig species (*Ficus costaricana*, *Ficus obtusifolia*, *Ficus popenoei*, and *Ficus trigonata*) with DBH > 500 mm DBH were excluded from the analysis [see @Rutishauser2020].

```{r remove-strangler-figs}
large_strangler_figs <- subset(df_stem, (
  dbh > 500 &
    Genus == "Ficus" &
    Species %in% c("costaricana", "obtusifolia", "popenoei", "trigonata")
))

df_stem <- subset(df_stem, ! stemID %in% large_strangler_figs$stemID)
```


## Estimate individual aboveground biomass using different methods 

We converted DBH values to cm in the data to match the units used in allometric equations.

```{r dbh-in-cm}
df_stem[, dbh := dbh/10]
```

No palm species, except *Socratea exorrhiza*, grows in diameter. Therefore, all changes in DBH of palms can be considered measurement errors. We replaced the DBH of palms by the species median DBH value over all censuses, except for *Socratea exorrhiza*, following @Rutishauser2020.

```{r median-dbh-palms}
df_stem[Family == "Arecaceae" & Genus != "Socratea", dbh := median(dbh, na.rm = TRUE), .(Latin)]
```

### Using different allometric equations

We tested two sets of allometries: the ones from @Chave2014 and from @Chave2005. For each set of allometry we used the equation with only DBH and wood specific gravity as explanatory variables, and the equation that includes height as well; in the latter case, we estimtaed height using the multi-species height allometry from @MartinezCano2019. For palms we used a multi-species palm allometry from @Goodman2013. 

```{r allometries}
# estimate agb values at BCI with allometric equations from Chave et al. 2014
# (method = "chave14") or Chave et al., 2005 (method = "chave05"); the height
# equation from Martinez Cano et al 2019 is used when use_height_allom = TRUE. 
# Results are returned in Mg of dry biomass. 
agb_bci <- function(dbh,  # dbh, in cm
                    wsg,  # wood specific gravity values 
                    palms = NULL,  # logical: is the individual a palm?
                    method = "chave14", 
                    use_height_allom = TRUE) {
  
  if (use_height_allom) {
    
    # with multi-species height allometry from Martinez Cano et al 2019
    h <- 58.0 * dbh ^ 0.73 / (21.8 + dbh ^ 0.73)
    
    if (method == "chave05") {
      # Chave et al 2005 - moist forests, with height (in Mg)
      agb <- 0.0509 * wsg * dbh ^ 2 * h / 1000
    }
    
    if (method == "chave14") {
      # Chave et al. 2014, equation 4 with the BIOMASS package 
      agb <- (0.0673 * (wsg * h * dbh^2)^0.976)/1000
    }
    
  } else {
    # without any height information
    
    if (method == "chave05") {
      # Chave et al 2005 - moist forests, without height (in Mg)
      agb <- wsg * exp(-1.499 + 2.148 * log(dbh) + 
                         0.207 * log(dbh) ^ 2 - 0.0281 * log(dbh) ^ 3) /1000
    }
    
    if (method == "chave14") {
      # Chave et al. 2014, equation 7 with the BIOMASS package (transform into kg)
      E <- 0.05176398
      agb <- exp(-2.023977 - 0.89563505 * E + 0.92023559 * 
                   log(wsg) + 2.79495823 * log(dbh) - 0.04606298 * (log(dbh)^2))/1000
    }
  }
  
  if (!is.null(palms))
    # palm specific allometry from Goodman et al. 2013
    agb[palms] <- 0.0417565 * dbh[palms] ^ 2.7483 /1000
  
  return(agb)
}
```



```{r estimate-agb-census}
# Chave et al 2014 allometric equation, no height information
df_stem[, chave14 := agb_bci(dbh = dbh, 
                             wsg = wsg, 
                             method = "chave14", 
                             use_height_allom = FALSE, 
                             palms = (Family == "Arecaceae"))]

# Chave et al 2014 allometric equation, tree height from Martinez Cano et al., 2019
df_stem[, chave14_h := agb_bci(dbh = dbh, 
                               wsg = wsg, 
                               method = "chave14", 
                               use_height_allom = TRUE, 
                               palms = (Family == "Arecaceae"))]

# Chave et al 2005 allometric equation, no height information
df_stem[, chave05 := agb_bci(dbh = dbh, 
                             wsg = wsg, 
                             method = "chave05", 
                             use_height_allom = FALSE, 
                             palms = (Family == "Arecaceae"))]

# Chave et al 2005 allometric equation, tree height from Martinez Cano et al., 2019
df_stem[, chave05_h := agb_bci(dbh = dbh, 
                               wsg = wsg, 
                               method = "chave05", 
                               use_height_allom = TRUE, 
                               palms = (Family == "Arecaceae"))]

## reference allometry: chave 2014 with local height allometry
df_stem[, agb := chave14_h]
```

### Applying the taper correction

The DBH of stems measured above 1.3 m was corrected for taper with the multi-species equation from @Cushman2014; the corrected DBH is stored in the `dbh_t` column and the corresponding aboveground biomass in the `agb_t` column. 

```{r taper-correction}
df_stem[, b := exp(-2.0205 - 0.5053 * log(dbh) + 0.3748 * log(hom))]
df_stem[!is.na(hom), dbh_t := dbh * exp(b * (hom - 1.3))]
df_stem[, agb_t := agb_bci(dbh = dbh_t, wsg = wsg, palms = (Family == "Arecaceae"))]
```


<!-- #### Interpolate missing DBHs -->

<!-- ```{r} -->
<!-- df_stem[, dbh_ti := interpolate_missing(dbh_t, year, DFstatus), .(stemID)] -->
<!-- missingIDs <- unique(subset(df_stem, is.na(dbh_t) & !is.na(dbh_ti))$stemID) -->
<!-- subset(df_stem, stemID==missingIDs[1])[, c("stemID", "year", "Latin", "dbh", "dbh_t", "dbh_ti")] -->

<!-- # remove non-measurements -->
<!-- df_stem <- subset(df_stem, !is.na(dbh_ti)) -->
<!-- df_stem[, dbh_t := dbh_ti] -->
<!-- ``` -->

### Estimating AGB growth

Individual trees' AGB growth (in Mg/yr) was estimated as the difference in AGB divided by the time interval between two measurements. This was done for both the original data and the taper corrected data.

```{r estimate-dbh-growth}
# order df_stem by treeID, stemID and year
data.table::setorder(df_stem, treeID, stemID, year)

# time interval between the measurement and the next
df_stem[, dT := c(diff(year), NA), .(stemID)]

# original data 
df_stem[, Ddbh := c(diff(dbh)/diff(year), NA), .(stemID)]
df_stem[, Dagb := c(diff(agb)/diff(year), NA), .(stemID)]

# taper corrected data
df_stem[, Ddbh_t := c(diff(dbh_t)/diff(year), NA), .(stemID)]
df_stem[, Dagb_t := c(diff(agb_t)/diff(year), NA), .(stemID)]
```

#### Correction for small stems in 1985

Small stems were rounded down to the nearest 5 mm in the 1985 census: this can potentially create biases when estimating AGB growth between the 1985 and 1990 censuses. To avoid this bias we substituted AGB values of trees DBH < 5.5 cm in 1985 and 1990, with mean AGB values measured in 1990 for each rounding class size groups. We then recalculated AGB growth between those two censuses with the substituted AGB values. 

```{r correct-initial-small-stem-growth}
small_stems <- df_stem[year == 1985 & dbh < 5.5, unique(stemID)]
df_small <- subset(df_stem, stemID %in% small_stems)

# round down small stems in 1990
df_small[dbh < 5.5, dbh_r := floor(dbh/0.5)*0.5]

# get small stems' mean AGB in 1990
mean_agb <- df_small[year==1990 & dbh < 5.5, .(agb_m = mean(agb)), .(dbh_r)]

# add mean AGB to the data frame
df_small <- merge(df_small, mean_agb, all = TRUE, by = "dbh_r")[order(stemID, year)]

# recalculate AGB growth
df_small[, Dagb_small := c(diff(agb_m)/diff(year), NA), .(stemID)]

# substitute AGB growth with new values in original data frame
df_small <- df_small[year==1985 & dbh < 5.5, c("stemID", "Dagb_small")]

df_stem <- merge(df_stem, df_small, all.x = TRUE)
df_stem[!is.na(Dagb_small) & year == 1985, `:=`(Dagb = Dagb_small, Dagb_t = Dagb_small)]
df_stem[, Dagb_small := NULL]
``` 

#### Outlier substitution

In cases where the change in DBH was $\leq$ -2.5 cm yr$^{-1}$ or $\geq$ 7.5 cm yr$^{-1}$ or when a change in the height of measurement was detected, the corresponding AGB change was substituted by the whole plot relative AGB change (sum(AGB change)/sum(AGB)), multiplied by the stem's AGB.

```{r outlier-substitution}
data.table::setorder(df_stem, stemID, date)

# outlier values: HOm change or abnormal DBH changes
df_stem[, hom_change := c(diff(hom) != 0, NA), .(stemID)]
df_stem[, hom_change := ifelse(is.na(hom_change) & !is.na(Ddbh),TRUE, hom_change)]
df_stem[, outlier := !is.na(Ddbh) & (hom_change | Ddbh > 7.5 | Ddbh < -2.5)]

# relative AGB change per plot for survivors , by size class
df_stem[, tot_rawp := sum(Dagb[!outlier],na.rm=T)/sum(agb[!outlier]), 
        .(size = cut(dbh, c(0, 10, 20, 50, 500)))]  

# substitute outliers' AGB and BA change
df_stem[, Dagb_s := ifelse(outlier == TRUE, tot_rawp*agb, Dagb)]

## check that there is no significant relationship between dbh and relative awp

# df_stem[order(dbh), .(tot_rawp = sum(Dagb[!outlier],na.rm=T)/sum(agb[!outlier])), 
#         .(size = cut(dbh, c(0, 10, 20, 50, 500)))] 
# df_stem[, .(tot_rawp_s = sum(Dagb[!outlier],na.rm=T)/sum(agb[!outlier]))]
# df_stem[, .(tot_rawp_s = sum(Dagb[!outlier & dbh >= 10],na.rm=T)/sum(agb[!outlier]))]

# df_keep <- df_stem[!hom_change & Ddbh < 5 & Ddbh > -0.5]
# df_keep[, `:=`(rawp = awp/agb, rbap = bap/ba)]
# regr <- lm(data = df_keep, log(rawp - min(rawp)+1e-16) ~ log(dbh) * plot)
# # pvalues < 10%?
# any(summary(regr)$coefficients[grep("\\(dbh\\):", rownames(summary(regr)$coefficients)),4] < 0.1)
```

<!-- For each stem in which one or more values of AGB change were substitute, the full time series of AGB is then reconstructed from outlier-substituted AGB change by taking the last AGB estimate as a starting point, and estimating prior AGB values by subtracting the estimated AGB changes. This could also be done by taking any other measurement as a reference (e.g. the first one); we opted to start with the last measurement because measurement quality is better in the later censuses.  -->

<!-- ```{r function-outlier-subs-corr-agb} -->
<!-- reconstruct <- function(x, # variable (must be ordered by increasing year) -->
<!--                         dx,  # changes in the variable between two censuses -->
<!--                         ref = 1 # position of the "reference" value of x -->
<!-- ) { -->
<!--   # cumulative sum (omitting NAs) -->
<!--   cx <- cumsum(ifelse(is.na(dx), 0, dx)) + dx*0 -->
<!--   cx <- c(0, cx[-length(cx)]) -->
<!--   # reconstruct AGB -->
<!--   y <- x[ref] - cx[ref] + cx -->
<!-- } -->

<!-- data.table::setorder(df_stem, year) -->
<!-- df_stem[, agb_ts := reconstruct(agb_t, Dagb_ts*dT, length(dT)), .(stemID)] -->
<!-- ``` -->

<!-- ```{r ex-outlier-subs-corr-agb, echo = FALSE, fig.cap = "Example of a stem (stemID: 134) with excessive DBH growth. The original (black points) and outlier-corrected (red points) AGB values are shown on the y-axis."} -->
<!-- dfcorr <- subset(df_stem, stemID==134) -->
<!-- plot(x = dfcorr$year, y = dfcorr$agb_ts, col = 2, pch = 16,  -->
<!--      xlab = "Year", ylab = "AGB (Mg)", main = "StemID = 134",  -->
<!--      ylim = c(13,26)) -->
<!-- points(x = dfcorr$year, y = dfcorr$agb_t, pch = 16) -->
<!-- ```  -->


### Estimating recruitment

We added recruitment fluxes to aboveground woody productivity, as the biomass of all stems that were first measured in the next census. 
<!-- We excluded AWP from trees recruited with DBH in cm greater than 10 + 5 * census interval in years, on the assumption that these are not truly new recruits.   -->

```{r add-recruitment}
# get previous measurement year_stem
df_stem[, qyear := median(year), .(quadrat, census_year)]
df_stem[, qdate := median(date), .(quadrat, census_year)]

prev_year <- df_stem[, .(qyear = sort(unique(qyear)), qdate=sort(unique(qdate)),
                         census_year=sort(unique(census_year))),  
                     .(quadrat)]
prev_year[, prevqyear := c(NA, qyear[-length(qyear)]), .(quadrat)]
prev_year[, prevqdate := c(NA, qdate[-length(qdate)]), .(quadrat)]
prev_year[, nextqdate := c(qdate[-1], NA), .(quadrat)]
prev_year[, prevcyear := c(NA, census_year[-length(census_year)]), .(quadrat)]
prev_year[, prevqdt := (qdate-prevqdate)/365.25]
prev_year[, qdt := (nextqdate - qdate)/365.25]

prev_year[quadrat=="", `:=`(prevqyear = 1985, prevqdate =  9196, nextqdate = 12878, 
                            prevcyear = 1985, prevqdt = 5.4, qdt = 4.68)]


df_stem <- merge(df_stem, prev_year[,c("quadrat","qyear","prevqyear","prevqdate", "nextqdate", 
                                       "prevcyear","prevqdt", "qdt")], 
                 by = c("quadrat", "qyear"))

# identify first measurement 
df_stem[, fmeas := (date == min(date)), .(stemID)]
recr <- df_stem[fmeas & census_year > 1985]

## check: recruits are small enough, their total biomass is not too large; exception is palms and secondary stems can recruit at large sizes
large_recruits <- recr[dbh > 10 + 7.5*prevqdt & StemTag==1 & Family != "Arecaceae", 
                       c("census_year", "sp", "Genus", "Species","treeID", "StemTag", 
                         "stemID", "qyear", "prevqyear","prevqdt", "dbh", "hom")]
large_recruits <- large_recruits[order(sp,census_year),]
large_recruits_all <- df_stem[treeID %in% large_recruits$treeID, ]
large_recruits_all <- large_recruits_all[order(large_recruits_all$sp,large_recruits_all$treeID,
                                               large_recruits_all$year,large_recruits_all$stemID),]

## solve problem
# recr <- recr[dbh < 10+7.5*prevqdt | StemTag>1 | Family=="Arecaceae"]

# change values: growth = agb value in next census / census interval, agb = 0,
# year = previous census year
recr[, `:=`(qyear = prevqyear, 
            year = prevqyear, 
            census_year = prevcyear,
            qdate = prevqdate,
            dT = prevqdt,
            date = NA, 
            year_stem = prevqyear,
            ExactDate = NA,
            DFstatus = "recruit",
            hom = NA,
            dbh = dbh,
            dbh_t = dbh_t,
            chave05 = 0, 
            chave05_h = 0, 
            chave14 = 0, 
            chave14_h = 0, 
            agb = 0, 
            agb_t = 0, 
            Dagb = agb/prevqdt,
            Dagb_t = agb_t/prevqdt,
            Dagb_s = agb/prevqdt
)]

# combine with stem data
df_stem <- rbind(df_stem, recr[, colnames(df_stem), with = FALSE])
```


### Estimating AGB mortality

Stems' aboveground woody mortality is zero when the stem is alive, and their AGB value (divided by the census interval) when they haven't been measured in the next census. 

```{r mortality}
# mortality census for each year (ie last census during which the stem was measured)
df_year_mort <- df_stem[, .(
  census_mort = max(census_year)
), .(stemID)]

df_stem <- merge(df_stem, df_year_mort, by = "stemID", all = TRUE)

df_stem[, `:=`(
  DagbM = agb * (!is.na(census_mort) & census_year == census_mort) / qdt,
  DagbM_t = agb_t * (!is.na(census_mort) & census_year == census_mort) / qdt
)]

## RM the missing stems are not considered as dead but are not accounted for in total biomass
```


## Aggregating plot-level AGB 

We first reorganized the stem censuses to a long format with a `variable` column (values: "agb" for AGB or "awp" for AGB changes) and a `method`column for the method used: allometry [@Chave2005 or @Chave2014; with or without the height allometry from @MartinezCano2019]; and correction type (original data with or without taper correction from @Cushman2014; with or without outlier substitution). 

```{r melt-table}
df_stem[, size := cut(dbh, c(1, 10, 20, 30, 50, 100, 320), include.lowest = TRUE)]

df_stem_melt <-
  data.table::melt(
    df_stem,
    id.vars = c("stemID", "treeID", "census_year", "quadrat", "DFstatus", "size", "sp"), 
    measure.vars = grep("chave|Dagb|agb_", colnames(df_stem)),
    variable.name = "method",
  )

df_stem_melt <- subset(df_stem_melt, !is.na(value))

# create variables: agb, awp, awm
df_stem_melt[, variable := c("agb", "awp", "awm")[1 + grepl("Dagb", method) + grepl("agbM", method)]]

# rename methods
df_stem_melt[grepl("_s", method), method := "chave14_h+subs"]
df_stem_melt[grepl("_t", method), method := "chave14_h+taper"]
df_stem_melt[method %in% c("Dagb", "DagbM"), method := "chave14_h"]

## for outlier substitution: add chave14_h for agb and awm
df_stem_melt_subs <- df_stem_melt[variable %in% c("agb", "awm") & method == "chave14_h"]
df_stem_melt_subs[, method := "chave14_h+subs"]
df_stem_melt <- rbind(df_stem_melt, df_stem_melt_subs)
```


<!-- ```{r some-tests} -->
<!-- list_status = lapply(seq(1985, 2010, 5), function(cns) { -->
<!--   test = df_stem[, .( -->
<!--     alive = all(c(cns, cns+5) %in% census_year), -->
<!--     recr = min(census_year) == (cns + 5), -->
<!--     dead = (unique(census_mort)==cns), -->
<!--     missing2 = (cns %in% census_year) & !((cns + 5) %in% census_year) & unique(census_mort) > cns, # stems missing in this census -->
<!--     missing1 = !(cns %in% census_year) & ((cns + 5) %in% census_year) & min(census_year) < (cns + 5), # stems missing in next census -->
<!--     agb = agb[census_year==cns], -->
<!--     agb_n = agb[census_year==cns+5]), -->
<!--     .(stemID)] -->

<!--   test = test[alive|dead|recr|missing1|missing2] -->

<!--   df = melt(test, id.vars = c("stemID", "agb", "agb_n"), measure.vars = c("alive", "recr", "missing1", "missing2", "dead"), variable.name = "status") -->
<!--   df = subset(df, value==TRUE)[, -"value"] -->

<!--   df_tot = df[, .(agb = sum(agb)/50, agb_n = sum(agb_n)/50), .(status)] -->
<!--   return(df_tot) -->
<!-- }) -->

<!-- names(list_status) = seq(1985, 2010, 5) -->

<!-- df_tot = rbindlist(list_status, idcol="year") -->

<!-- df_tot[, .(sum(agb_n, na.rm=TRUE)), .(year)] -->
<!-- df_plot[method=="chave14_h" & variable=="agb"] -->

<!-- df1 = df_tot[, .(growth = (sum(agb_n[status=="alive"]) - sum(agb[status=="alive"]))/5, -->
<!--                  awp = (sum(agb_n[status %in% c("recr", "alive")], na.rm = TRUE) -  -->
<!--                           sum(agb[status %in% c("recr", "alive")], na.rm = TRUE))/5, -->
<!--                  awm = (sum(agb[status =="dead"], na.rm = TRUE) )/5, -->
<!--                  recr = sum(agb_n[status %in% c("recr") ])/5), .(year = as.numeric(year))] -->

<!-- df2 = df_stem[, .( -->
<!--   growth = sum(Dagb[agb!=0], na.rm = TRUE)/50,  -->
<!--   recr = sum(Dagb[agb==0], na.rm = TRUE)/50,  -->
<!--   awm = sum(DagbM, na.rm = TRUE)/50,  -->
<!--   awp = sum(Dagb, na.rm = TRUE)/50),  -->
<!--   .(year = census_year)] -->

<!-- df3 = df_plot[method=="chave14_h" & variable=="awm"] -->

<!-- df4 = df_stem_melt[, .( -->
<!--   awp = sum(value[variable=="awp"])/50), -->
<!--   .(year = census_year, method)] -->
<!-- df4 = subset(df4, awp!=0) -->

<!-- merge(df2, df1, by = "year") -->
<!-- merge(df2, df3[, c("year", "tot")], by = "year") -->
<!-- ``` -->

Finally, we apply the correction proposed by @Kohyama2019 to correct estimates of woody productivity for unrecorded growth between two censuses. 

```{r kohyama-correction}
kohyama_correction <- function(stock, gain, loss, dT, output = "prod") {
  B0 <- stock
  BS0 <- B0 - loss * dT
  BT <- B0 + (gain - loss) * dT
  if (output == "prod") {
    outp <- (log(BT / BS0) * (BT - B0)) / (dT * log(BT / B0))
  } else if (output == "mort"){
    outp <- (log(B0 / BS0) * (BT - B0)) / (dT * log(BT / B0))
  } else 
    stop("Please provide either 'prod' (production) or 'mort' (mortality) as an output.")
  return(outp)
}
```

Below is a function that aggregates AGB and AWP values according to a grouping factor, and applies the correction from @Kohyama2019. 

```{r aggr-agb-dyn-function}
aggregate_agb_dyn <- function(group, # grouping factor
                              area,  # unit area 
                              nboot = 0, # bootstrap over quadrats?
                              kohyama = FALSE, # apply the Kohyama et al 2019 correction?
                              delta = FALSE # calculate annualized changes in AGB values and associated uncertainties?
) {
  
  # get long format table with aggregated values 
  if (nboot > 0) {
    
    df <- df_stem_melt[,  .(value = sum(value) / area),
                       .(variable, year = census_year, group = get(group), quadrat)]
    
    # wide format for kohyama correction
    df <- data.table::dcast(df, year + group + quadrat ~ variable)
    df[order(year), dT := c(diff(year), NA), .(group, quadrat)]
    
    if (delta) # get change in agb
      df[order(year), dagb := c(diff(agb)/diff(year), NA), .(group, quadrat)]
    
  } else {
    
    df <- df_stem_melt[,  .(value = sum(value) / area),
                       .(variable, year = census_year, group = get(group))]
    
    # wide format for kohyama correction
    df <- data.table::dcast(df, year + group ~ variable)
    df[order(year), dT := c(diff(year), NA), .(group)]
    
    if (delta) # get change in agb
      df[order(year), dagb := c(diff(agb)/diff(year), NA), .(group)]
  }
  
  if (kohyama) {
    # avoid NAs and change them into zeros (no observation = null flux)
    df[is.na(awp) & year != max(year), awp := 0]
    df[is.na(awm) & year != max(year), awm := 0]
    # apply Kohyama correction 
    df[, awp := kohyama_correction(agb, awp, awm, dT, output = "prod")]
    df[, awm := kohyama_correction(agb, awp, awm, dT, output = "mort")]
  }
  
  # to long format
  df <- data.table::melt(df, 
                         measure.vars = grep("agb|aw", colnames(df), value  = TRUE), 
                         id.vars = c("group", "year"))
  df <- subset(df, !is.na(value))
  
  if (nboot > 0) {
    df <- df[, .(tot = sum(value),
                 lwr = bootstrap_q(value, nboot, pb = 0.025), 
                 upr = bootstrap_q(value, nboot, pb = 0.975)), 
             .(group, year, variable)]
  }
  
  colnames(df)[1] <- group
  return(df)
}

## simple bootstrap function
bootstrap_q <-  function(x, k, pb = c(0.025, 0.975)) {
  xs <- sapply(seq_len(k), function(i) sum(sample(x, length(x), replace = TRUE)))
  return(quantile(xs, probs = pb))
}
```

We first estimated the plot-level annual AGB and AWP for each method used. 

```{r aggr-by-methods}
df_plot <- 
  aggregate_agb_dyn(
    group = "method",
    area = 50,
    kohyama = FALSE, 
    nboot = 1000, 
    delta = TRUE
  )

df_plot_kohyama <- subset(aggregate_agb_dyn(
  group = "method",
  area = 50,
  kohyama = TRUE, 
  nboot = 1000, 
  delta = TRUE
), variable %in% c("awp", "awm"))
df_plot_kohyama[, method := paste0(method, "+kohyama")]

df_plot <- rbind(df_plot, df_plot_kohyama)
```

For all other aggregated AGB data, we used taper-corrected DBHs, the @Chave2014 allometric equation (without height), and applied outlier substitution for AWP but not AGB.   

```{r subset-corrections}
df_stem_melt <- subset(df_stem_melt, method == "chave14_h+subs")
```

We also calculated the mean AGB and AWP by size class over all years. 

```{r aggr-by-size}
df_size <- aggregate_agb_dyn(group = "size", area = 50, nboot = 1000)
```

To group species into functional groups we used plant functional types as described in @Ruger2020. The data was downloaded from their supplementary material. 

```{r get-ruger-data}
if (!file.exists("ruger_data_s1.xlsx")) {
  ruger_url <- "https://www.science.org/doi/suppl/10.1126/science.aaz4797/suppl_file/aaz4797_ruger_data_s1.xlsx"
  download.file(ruger_url, destfile = "ruger_data_s1.xlsx", mode = "wb")
} 

ruger_data <- openxlsx::read.xlsx("ruger_data_s1.xlsx", sheet = "Data")
ruger_data$sp <- tolower(ruger_data$sp)

# change PFT names
ruger_levels <- strsplit("1=slow, 2=fast, 3=LLP, 4=SLB, 5=intermediate", "=|, ")[[1]]
ruger_levels <- data.frame(matrix(ruger_levels, ncol = 2, byrow = TRUE))
colnames(ruger_levels) = c("PFT_2axes", "PFT")

ruger_data <- merge(ruger_data, ruger_levels)
```

*Swartzia simplex* has two subspecies but only one is represented in the data from @Ruger2020. We gave both subspecies the same plant functional type. 

```{r change-swartzia}
swartzia2 <- subset(ruger_data, Genus=="Swartzia")
swartzia2$sp <- "swars2"
ruger_data <- rbind(ruger_data, swartzia2)
``` 

Species plant functional types were then added to the census data, and we calculated the mean of AGB and AWP across censuses by plant functional type. 

```{r aggr-by-pft}
df_stem_melt <- merge(df_stem_melt, ruger_data[, c("sp", "PFT")], by = "sp", all.x = TRUE)

df_pft <- aggregate_agb_dyn("PFT", area = 50, nboot = 1000)
``` 

<!-- Russo et al. 2020: didn't find codes and data on fgeo github repo -->

<!-- Powell et al 2018: not real data (uses 1 value per PFT) -->

#### Test other deifinition of plant functional types: Rubio et al 2022

```{r rubio-2022}
# download supporting information file (word doc) from Rubio et al 2022 
# https://besjournals.onlinelibrary.wiley.com/doi/10.1111/1365-2745.13795
if (!file.exists("ruger_data_s1.xlsx")) {
  rubio_url <- "https://besjournals.onlinelibrary.wiley.com/action/downloadSupplement?doi=10.1111%2F1365-2745.13795&file=jec13795-sup-0001-Supinfo.docx"
  # extract table s1 from doc
  download.file(rubio_url, destfile = "rubio_si.docx", mode = "wb")
}

rubio_si <- docxtractr::read_docx("rubio_si.docx") 
rubio_tab <- docxtractr::docx_extract_tbl(rubio_si, 1)

# reformat table to be machine readable
rubio_tab <- rbind(rubio_tab[,1:2], rubio_tab[,3:4], 
                   rubio_tab[5:6], rubio_tab[,7:8])
rubio_tab <- subset(rubio_tab, FG != "")

# correct typos 
rubio_tab$Species[rubio_tab$Species == "Erythrina costaricensi"] <- "Erythrina costaricensis"
rubio_tab$Species[rubio_tab$Species == "Lacmella panamensis"] <- "Lacmellea panamensis"

# remove quotes from species names
rubio_tab$Species <- gsub("'", "", rubio_tab$Species)

# different fg for subspecies?
rubio_tab$Genus <- data.table::tstrsplit(rubio_tab$Species, " ")[[1]]
rubio_tab$Species <- data.table::tstrsplit(rubio_tab$Species, " ")[[2]]
rubio_tab$name <- paste(rubio_tab$Genus, rubio_tab$Species)

# Erythroxylum panamense is in both groups 1 and 2 > change to group 2 only
# because there is one other species from same genus (Erythroxylum macrophyllum)
# in group 2 > more likely that Erythroxylum panamense is also in group 2
rubio_tab <- subset(rubio_tab, !(Genus == "Erythroxylum" & FG == 1))

# find synonyms of BCI species names
# > get all synonyms of BCI species from bci.spptable
syns <- strsplit(bci.spptable$syn, ",")
names(syns) <- bci.spptable$sp
syns <- unlist(syns, use.names = TRUE)
df_syn <- data.frame(sp = names(syns), Latin = syns)
# add species' original name to the list of synonyms
df_syn <- rbind(subset(df_syn, !is.na(Latin)), bci.spptable[, c("sp", "Latin")])

# keep only genus + species 
df_syn$name <- do.call(paste, data.table::tstrsplit(df_syn$Latin, " ")[1:2])

# match synonyms
rubio_tab <- merge(rubio_tab, df_syn, by = "name", all.x = TRUE)

# change to accepted synonym
rubio_tab$sp[rubio_tab$name == "Zanthoxylum juniperinum"] <- "zantpr"

rubio_tab <- unique(rubio_tab[, c("sp", "FG")])

# check match with bci data
tabsp <- merge(df_stem[, .(n = length(stemID), agb = sum(agb)), .(sp)], 
               rubio_tab, by = c("sp"), all.x= TRUE)
tabsp[,.(pa = sum(agb) / sum(tabsp$agb)*100, ps = sum(n) / sum(tabsp$n)*100), .(FG)]
# 8.6% of unmatched stems, 10% of unmatched biomass
```

Species plant functional types were then added to the census data, and we calculated the mean of AGB and AWP across censuses by plant functional type. 

```{r aggr-by-pft-rubio}
df_stem_melt <- merge(df_stem_melt, rubio_tab, by = "sp", all.x = TRUE)

df_pft2 <- aggregate_agb_dyn("FG", area = 50, nboot = 1000)
``` 


## Crown-distributed AGB and AWP

We defined a function (`dist_crowns`) that distributes the aboveground biomass and woody productivity of each tree over its estimated crown area. Each crown is centered on the mapped trunk location, and the radius of the crown is calculated based on the multi-species crown allometry from @MartinezCano2019. The function first creates a grid of pixels of a given width (here set to 2m) over the entire plot. In order to avoid underestimating the AGB and AWP at the plot edges, the grid also includes pixels outside the plot boundaries where the crowns of trees from within the plot fall. The AGB and AWP of each pixel are then calculated as the sum of the taper-corrected AGB (or taper- and outlier-corrected AWP) of each tree multiplied by the proportion of the tree’s crown that is within the pixel. The AGB and AWP of the pixels outside the plot boundaries are then mirrored back into the plot by adding them to the opposite pixels inside the plot boundaries.


```{r dist-crowns}
# get crown distributed aboveground biomass density
dist_crowns <- function(wpix, # height of pixels in m
                        gx, gy, # position of trees in the plot, in m
                        rcrown, # radius of tree crowns
                        values # list of value vectors to be distributed (eg AGB)
) {
  
  if (!is.list(values) | any(lapply(values, length) != length(gx)))
    stop("`values` should be a list of vectors, each the length of gx, gy and rcrown.")
  
  # define grid limits, including all pixels in which a tree crown falls
  xmin <- floor(min(gx - rcrown) / wpix) * wpix
  xmax <- ceiling(max(gx + rcrown) / wpix) * wpix
  ymin <- floor(min(gy - rcrown) / wpix) * wpix
  ymax <- ceiling(max(gy + rcrown) / wpix) * wpix
  
  # create grid
  grid <- expand.grid(x = seq(xmin, xmax - wpix, by = wpix) + (wpix/2),
                      y = seq(ymin, ymax-wpix, by = wpix) + (wpix/2))
  data.table::setDT(grid)
  # give each pixel a unique identifier
  grid$pixID <- 1:nrow(grid)
  
  # for each pixel, select trees that could be in it (distance between the
  # center of the pixel and the tree is less than the radius of the crown + the
  # distance between the center of the pixel and its corners = sqrt(2)/2*wpix)
  
  dfpix <-
    grid[, .(stems = which(sqrt((x - gx) ^ 2 + (y - gy) ^ 2) < rcrown + sqrt(2) / 2 * wpix)), .(pixID, x, y)]
  
  dfpix$rcrown <- rcrown[dfpix$stems]
  dfpix$gx <- gx[dfpix$stems]
  dfpix$gy <- gy[dfpix$stems]
  
  dfpix[, parea := area_circle_square(x - wpix / 2, y - wpix / 2, wpix, gx, gy, rcrown) /
          (rcrown ^ 2 * pi), .(stems, pixID)]
  
  
  # mirror pixels outside the plot back inside the plot
  
  dfpix[, `:=`(x = abs(1000-abs(1000-x)), y = abs(500-abs(500-y)))]
  
  # aggregate values per pixel
  
  dfdist <- unique(dfpix[, c("x", "y")])
  
  for (i in 1:length(values)) {
    dfpix$value <- values[[i]][dfpix$stems]
    
    dfdisti <-
      dfpix[, .(value = sum(parea * value, na.rm = TRUE) / (wpix / 100) ^ 2),
            .(x, y)]
    colnames(dfdisti)[3] <- paste0("value", i)
    
    dfdist <- merge(dfdist, dfdisti, by = c("x", "y"))
  }
  
  return(dfdist)
}


# area of the intersection of a circle and a rectangle ####

# returns the positive root of intersection of line y = h with circle centered
# at the origin and radius r
section <- function(h, r = 1)
{
  # assert(r >= 0); # assume r is positive, leads to some simplifications in the
  # formula below (can factor out r from the square root)
  return(ifelse(h < r, sqrt(r * r - h * h), 0))
}

# indefinite integral of circle segment
g <- function(x, h, r = 1)
{
  return(.5 * (sqrt(1 - x * x / (r * r)) * x * r + r * r * asin(x / r) - 2 * h * x))
}

# area of intersection of an infinitely tall box with left edge at x0, right
# edge at x1, bottom edge at h and top edge at infinity, with circle centered at
# the origin with radius r
area_inf <- function(x0, x1, h, r)
{
  if (x0 > x1) {
    # swap x0 and x1 to avoid getting a negative area
    x0s <- x0
    x0 <- x1
    x1 <- x0s
  } 
  
  s <- section(h, r)
  # integrate the area
  return(g(max(-s, min(s, x1)), h, r) - g(max(-s, min(s, x0)), h, r))
}

# area of the intersection of a square (lower corner coordinates: (x0, y0) and
# width w) with a circle of center cx, cy and radius r

area_circle_square <- function(x0, y0, w, cx, cy, r)
{
  # translate square to have the equivalent of a centered circle
  x1 <- (x0 + w) - cx; x0 <- x0 - cx;
  y1 <- (y0 + w) - cy; y0 <- y0 - cy;
  
  # area of the intersection of a finite box with a circle centered at the origin with radius r
  if (y0 > y1) {
    # swap y0 and y1 
    y0s <- y0
    y0 <- y1
    y1 <- y0s
  } 
  
  if (y0 >= 0) {
    # y1 > y0 >=0
    
    # area of the lower box minus area of the higher box:
    return(area_inf(x0, x1, y0, r) - area_inf(x0, x1, y1, r))
    
  } else {
    if (y1 < 0) {
      
      # the box is completely under, just flip it above (opposite y coordinates)
      return(area_inf(x0, x1, -y1, r) - area_inf(x0, x1, -y0, r))
      
    } else # the box is both above and below, divide it to two boxes
      return(area_inf(x0, x1, 0, r) - area_inf(x0, x1, -y0, r) +
               area_inf(x0, x1, 0, r) - area_inf(x0, x1, y1, r))
  }
}

dftemp <- df_stem[year==2010]

# crown allometry from Martinez Cano et al., 2019
dftemp[, rcrown := sqrt((0.57 * dbh_t ^ 1.34)/pi) ]
dftemp[, dbh_t := NULL]

df_crown <- dist_crowns(wpix = 2,
                        gx = dftemp$gx,
                        gy = dftemp$gy,
                        rcrown = dftemp$rcrown,
                        values = list(dftemp$agb, 
                                      dftemp$Dagb_s, 
                                      dftemp$DagbM))
colnames(df_crown)[3:5] <- c("agb", "awp", "awm")
```


```{r save-results, echo = FALSE}
df_ind <- subset(df_stem, stemID %in% c(2031, 3671, 1428))

save(df_plot, df_size, df_pft, df_pft2, df_ind, df_crown, file = "cache.rda")
```


# References