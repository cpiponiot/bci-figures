---
title: "Supplementary material - Woody Biomass Stocks and Fluxes in the Barro Colorado Island 50 ha Plot"
author:
  - Camille Piponiot:
      email: camille.piponiot-laroche@cirad.fr
      institute: [fs]
  - Helene C. Muller-Landau:
      institute: [stri] 

institute:
  - fs: Cirad, Université de Montpellier, UR Forests and Societies, 34980 Montferrier-sur-Lez, France
  - stri: Forest Global Earth Observatory, Smithsonian Tropical Research Institute, Apartado Postal 0843-03092, Panamá, Republic of Panamá

output: 
  html_document:
    code_folding: hide
    pandoc_args:
      - '--lua-filter=common/scholarly-metadata.lua'
      - '--lua-filter=common/author-info-blocks.lua'
bibliography: references.bib
csl: common/new-phytologist.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, results = "hide")
```

# Detailed methods and codes

## Get census data ready

Census data was downloaded from an online Dryad repository [@Condit2019]. Census data contain 8 censuses of the Barro Colorado 50-ha plot, from 1981 to 2015, of all stems from 1 cm of diameter at breast height (`dbh`).

```{r download-bci-data}
dryad_data_path <- rdryad::dryad_download("10.15146/5xcp-0d46")

# unzip files
zip_files <- grep("\\.zip", dryad_data_path$`10.15146/5xcp-0d46`, value = TRUE)
zip_folders <- sapply(zip_files, function(dir) {
  name <- gsub("\\.zip", "", data.table::last(strsplit(dir, '/')[[1]]))
  utils::unzip(dir, exdir = name)
})
```

The first census was usually removed from biomass analyses because buttressed trees with irregular trunks were measured at breast height, thus creating a strong bias in the biomass estimations. 

```{r load-and-remove-first-census}
# 1. list census files, except first census (which has problematic measurements
# of large trees)
bci_stem <- list.files("bci.stem")[-1]

# 2. load census files as list
census_list <- lapply(bci_stem, function(name) {
  load(paste0("bci.stem/", name)); get(strsplit(name, "\\.rda")[[1]][1])
})

# 3. add census number information as list names
names(census_list) <- data.table::tstrsplit(bci_stem, "\\.")[[2]]

# 4. compile as one data table
df_stem <- data.table::rbindlist(census_list, fill = TRUE, idcol = "censusID")
```

Each individual stem was identified to the lowest taxonomic level possible (100% genus; 98% species; 3% subspecies) and was given a species code (`sp`). An independent species table (`bci.spptable`) contains all the taxonomic detail for each species code (species Latin name, family, subspecies when relevant, wood specific gravity).

```{r add-species-info}
load(grep("spp", dryad_data_path$`10.15146/5xcp-0d46`, value = TRUE))

df_stem <- merge(df_stem, bci.spptable, by = "sp", all.x = TRUE) 
```

The exact date of measurement was recorded in the `ExactDate` column; the year of each census was estimated as the median of all measurement years for this census. 

```{r add-census-year}
df_stem[, year := as.numeric(data.table::tstrsplit(ExactDate, "-")[[1]])]
df_stem[, census_year := median(year, na.rm = TRUE), .(censusID)]
```

Only stems above 10 mm DBH and alive were kept in the analysis.  

```{r remove-smallest-stems}
df_stem <- subset(df_stem, dbh >= 10 & grepl("A", status))
```

Individuals of strangler fig species (*Ficus costaricana*, *Ficus obtusifolia*, *Ficus popenoei*, and *Ficus trigonata*) with DBH > 50 cm DBH were excluded from the analysis [see @Rutishauser2020].

```{r remove-strangler-figs}
large_strangler_figs <- subset(df_stem, (
  dbh > 50 &
    Genus == "Ficus" &
    Species %in% c("costaricana", "obtusifolia", "popenoei", "trigonata")
))

df_stem <- subset(df_stem, ! stemID %in% large_strangler_figs$stemID)
```


## Estimate individual aboveground biomass using different methods 

We converted DBH values to cm in the data to match the units used in allometric equations.

```{r dbh-in-cm}
df_stem[, dbh := dbh/10]
```

No palm species, except *Socratea exorrhiza*, grows in diameter. Therefore, all changes in DBH of palms can be considered measurement errors. We replaced the DBH of palms by the species median DBH value over all censuses, except for *Socratea exorrhiza*, following @Rutishauser2020.

```{r median-dbh-palms}
df_stem[Family == "Arecaceae" & Genus != "Socratea", dbh := median(dbh, na.rm = TRUE), .(Latin)]
```

### Using different allometric equations

We tested two sets of allometries: the ones from @Chave2014 and from @Chave2005. For each set of allometry we used the equation with only DBH and wood specific gravity as explanatory variables, and the equation that includes height as well; in the latter case, we estimtaed height using the multi-species height allometry from @MartinezCano2019. For palms we used a multi-species palm allometry from @Goodman2013. 

```{r allometries}
# estimate agb values at BCI with allometric equations from Chave et al. 2014
# (method = "chave14") or Chave et al., 2005 (method = "chave05"); the height
# equation from Martinez Cano et al 2019 is used when use_height_allom = TRUE. 
# Results are returned in Mg. 
agb_bci <- function(dbh,  # dbh, in cm
                    wsg,  # wood specific gravity values 
                    palms = NULL,  # logical: is the individual a palm?
                    method = "chave14", 
                    use_height_allom = FALSE) {
  # with multi-species height allometry from Martinez Cano et al 2019
  if (use_height_allom) {
    # Chave et al 2005 - moist forests, with height (in Mg)
    h <- 58.0 * dbh ^ 0.73 / (21.8 + dbh ^ 0.73)
    if (method == "chave05") {
      agb <- 0.0509 * wsg * dbh ^ 2 * h / 1000
    }
    if (method == "chave14") {
      # Chave et al. 2014, equation 4 with the BIOMASS package 
      agb <- (0.0673 * (wsg * h * dbh^2)^0.976)/1000
    }
  } else {
    # without any height information
    # Chave et al 2005 - moist forests, without height (in Mg)
    if (method == "chave05") {
      agb <- wsg * exp(-1.499 + 2.148 * log(dbh) + 
                         0.207 * log(dbh) ^ 2 - 0.0281 * log(dbh) ^ 3) /1000
    }
    if (method == "chave14") {
      # Chave et al. 2014, equation 7 with the BIOMASS package (transform into kg)
      E <- 0.05176398
      agb <- exp(-2.023977 - 0.89563505 * E + 0.92023559 * 
                   log(wsg) + 2.79495823 * log(dbh) - 0.04606298 * (log(dbh)^2))/1000
    }
  }
  
  ## palm specific allometry
  if (!is.null(palms))
    agb[palms] <- 0.0417565 * dbh[palms] ^ 2.7483 /1000
  
  return(agb)
}
```



```{r estimate-agb-census}
# Chave et al 2014 allometric equation, no height information
df_stem[, chave14 := agb_bci(dbh = dbh, 
                             wsg = wsg, 
                             method = "chave14", 
                             palms = (Family == "Arecaceae"))]

# Chave et al 2014 allometric equation, tree height from Martinez Cano et al., 2019
df_stem[, chave14_h := agb_bci(dbh = dbh, 
                               wsg = wsg, 
                               method = "chave14", 
                               use_height_allom = TRUE, 
                               palms = (Family == "Arecaceae"))]

# Chave et al 2005 allometric equation, no height information
df_stem[, chave05 := agb_bci(dbh = dbh, 
                             wsg = wsg, 
                             method = "chave05", 
                             palms = (Family == "Arecaceae"))]

# Chave et al 2005 allometric equation, tree height from Martinez Cano et al., 2019
df_stem[, chave05_h := agb_bci(dbh = dbh, 
                               wsg = wsg, 
                               method = "chave05", 
                               use_height_allom = TRUE, 
                               palms = (Family == "Arecaceae"))]
```

### Applying the taper correction

The DBH of stems measured above 1.3 m was corrected for taper with the multi-species equation from @Cushman2014; the corrected DBH is stored in the `dbh_t` column and the corresponding aboveground biomass in the `agb_t` column. 

```{r taper-correction}
df_stem[, b := exp(-2.0205 - 0.5053 * log(dbh) + 0.3748 * log(hom))]
df_stem[!is.na(hom), dbh_t := dbh * exp(b * (hom - 1.3))]
df_stem[, agb_t := agb_bci(dbh = dbh_t, wsg = wsg, palms = (Family == "Arecaceae"))]
```


<!-- #### Interpolate missing DBHs -->

<!-- ```{r} -->
<!-- df_stem[, dbh_ti := interpolate_missing(dbh_t, year, DFstatus), .(stemID)] -->
<!-- missingIDs <- unique(subset(df_stem, is.na(dbh_t) & !is.na(dbh_ti))$stemID) -->
<!-- subset(df_stem, stemID==missingIDs[1])[, c("stemID", "year", "Latin", "dbh", "dbh_t", "dbh_ti")] -->

<!-- # remove non-measurements -->
<!-- df_stem <- subset(df_stem, !is.na(dbh_ti)) -->
<!-- df_stem[, dbh_t := dbh_ti] -->
<!-- ``` -->

### Estimating AGB growth

Individual trees AGB growth (in Mg/yr) was estimated as the difference in AGB divided by the time interval between two measurements. This was done for both the original data and the taper corrected data.

```{r estimate-dbh-growth}
# order df_stem by treeID, stemID and year
data.table::setorder(df_stem, treeID, stemID, year)

# time interval between the measurement and the next
df_stem[, dT := c(diff(year), NA), .(stemID)]

# original data 
# df_stem[, Ddbh := c(diff(dbh)/diff(year), NA), .(stemID)]
df_stem[, Dagb := c(diff(agb_t)/diff(year), NA), .(stemID)]

# taper corrected data
df_stem[, Ddbh_t := c(diff(dbh_t)/diff(year), NA), .(stemID)]
df_stem[, Dagb_t := c(diff(agb_t)/diff(year), NA), .(stemID)]
```

#### Correction for small stems in 1985

Small stems were rounded down to the nearest 5 mm in the 1985 census: this can potentially create biases when estimating AGB growth between the 1985 and 1990 censuses. To avoid this bias we 
substituted AGB values of trees DBH < 5.5 cm in 1985 and 1990, with mean AGB values measured in 1990 for each rounding class size groups. We then recalculated AGB growth between those two censuses with the substituted AGB values. 

```{r correct-initial-small-stem-growth}
small_stems <- df_stem[year == 1985 & dbh < 5.5, unique(stemID)]
df_small <- subset(df_stem, stemID %in% small_stems)

# round down small stems in 1990
df_small[dbh < 5.5, dbh_r := floor(dbh/0.5)*0.5]

# get small stems' mean AGB in 1990
median_agb <- df_small[year==1990 & dbh < 5.5, .(agb_m = mean(agb)), .(dbh_r)]

# add mean agb to the data frame
df_small <- merge(df_small, median_agb, all = TRUE, by = "dbh_r")[order(stemID, year)]

# recalculate dbh growth
df_small[, Dagb_small := c(diff(agb_m)/diff(year), NA), .(stemID)]

# substitute dbh growth with new values in original data frame
df_small <- df_small[year==1985 & dbh < 5.5, c("stemID", "Dagb_small")]

df_stem <- merge(df_stem, df_small, all.x = TRUE)
df_stem[!is.na(Dagb_small), `:=`(Dagb = Dagb_small, Dagb_t = Dagb_small)]
df_stem[, Dagb_small := NULL]
``` 

#### Outlier substitution

In cases where the change in DBH was $\leq$ -0.5 cm yr$^{-1}$ or $\geq$ 5 cm yr$^{-1}$, the corresponding AGB change was substituted with the expected value, calculated from DBH changes of all other stems in the same site and size class, as detailed below.

DBH distribution of each diameter class $b$ was approximated with a normal distribution of mean $\mu_{b}$ and standard deviation $\sigma_{b}$ after transforming DBH values with the modulus function (with parameter $\lambda = 0.5$) to remove the skewness [see @Condit2017 and @Piponiot2021]. 

We calculated the expected change in AGB for any given stem by integrating the AGB allometry with the expected DBH change distribution for the appropriate site and size class, given that stem’s initial DBH.

The modulus function used to transform DBH changes is defined as:

\begin{equation}
mod(x) = \left\{
\begin{array}{ll}
x^{\lambda}\hspace{1cm} \text{ if }x \geq 0\\
-(-x)^{\lambda}\text{ if }x <0
\end{array}
\right.
\end{equation}

The expected DBH change in site $s$ and diameter class $b$ change is then:

\begin{equation}
[E(dDBH)]_{s,b} = \int_{-\infty}^{+\infty} mod^{-1}(x)\cdot \varphi\left(\frac{x-\mu_{s,b}}{\sigma_{s,b}}\right)\cdot dx
\end{equation}

For each stem $i$ in site $s$ and diameter class $b$ with initial DBH $D_i$, we calculated the expected AGB change as

\begin{equation}
[E(dAGB)]_i = \int_{dmin}^{+\infty} \left(AGB(D_i+mod^{-1}(x))-AGB(D_i)\right) \cdot \frac{\varphi\left(\frac{x-\mu_{s,b}}{\sigma_{s,b}}\right)}{1-\Phi\left(\frac{x-\mu_{s,b}}{\sigma_{s,b}}\right)}\cdot dx
\end{equation}

with $D_i+mod^{-1}(dmin) = 0$ $\Rightarrow$ $dmin = - D_i^\lambda$ (to avoid negative AGB values), $AGB$ is the allometric equation used in site $s$, and $\varphi$ and $\Phi$ are respectively the probability and cumulative density functions of the standard normal distribution.

```{r function-outlier-substitution}
substitute_change = function(varD,  # dbh variation (cm/yr)
                             dT,    # time interval between two censuses
                             cut = c(-0.5, 5), # threshold of acceptable dbh change
                             lambda = 0.5,
                             value = "D", # output: either "D" (DBH change) or "AGB" (AGB change)
                             D = NULL,   # when calculating expected AGB change, need to provide corresponding DBH
                             WD = NULL,  # when calculating expected AGB change, need to provide corresponding wood gravity
                             palms = NULL # logical: is the individual a palm?
) {
  
  # values to keep
  keep_values <- which(varD > cut[1] & varD < cut[2] & !is.na(varD))
  
  # outliers
  change_values <- which((varD <= cut[1] | varD >= cut[2]) & !is.na(varD))
  
  # distribution of modulus-transformed dbhs
  transf_values <- modulus(varD[keep_values], lambda)
  mu <- mean(transf_values)
  sigma <- sd(transf_values)
  
  # expected value of dbh change
  if (value == "D") {
    diffModD <- function(x) modulus(x, 1 / lambda) * dnorm(x, mu, sigma)
    varD[change_values] <- integrate(diffModD, -Inf, Inf)$value
    return(varD)
  }
  
  # expected value of agb change
  if (value == "AGB") {
    dAGB = (agb_bci(dbh = D + varD*dT, wsg = WD, palms) - 
              agb_bci(dbh = D, wsg = WD, palms))/dT
    if (length(change_values) == 1) {
      dAGB[change_values] <- ExpDiffAGB(
        d = D[change_values],
        wsg = WD[change_values],
        lambda = lambda,
        mu = mu,
        sigma = sigma
      )
    } else if (length(change_values) > 1) {
      dAGB[change_values] = apply(cbind(D, WD)[change_values, ], 1, function(x) {
        ExpDiffAGB(
          d = x[1],
          wsg = x[2],
          lambda = lambda,
          mu = mu,
          sigma = sigma
        )
      })
    }
    return(dAGB)
  }
}

modulus <- function(d, lambda = 0.5) {
  return(sign(d) * abs(d) ^ lambda)
}

ExpDiffAGB <- function(d, wsg, lambda, mu, sigma, palms = NULL) {
  # AGB > 0 => d + modulus(x, 1/lambda) > 0 => x > -(d^lambda)
  minVar <- -d ^ lambda
  pdfdAGB <- function(x) {
    dAGB = agb_bci(d + modulus(x, 1 / lambda), wsg, palms) - agb_bci(d, wsg, palms)
    dens = truncnorm::dtruncnorm(x, mean = mu, sd = sigma, a = minVar)
    return(dAGB * dens)
  }
  return(integrate(pdfdAGB, lower = minVar, upper = Inf)$value)
}
```


Diameter classes were defined as follows: $[1,10]$, $(10,20]$, $(20,30]$, $(30,50]$, $(50,100]$, $(100,320]$ (in cm).

```{r create-size-classes}
maxD <- ceiling(max(df_stem$dbh_t, na.rm = TRUE))
df_stem[, size := cut(dbh_t, c(1, 10, 20, 30, 50, 100, maxD), include.lowest = TRUE)]
```

Outlier values of AGB changes (after the taper correction) were then substituted with the expected AGB change for the corresponding diameter class. 

```{r outlier-substitution}
## change abnormal agb changes, grouping by size
df_stem[!is.na(Ddbh_t), `:=`(
  Dagb_ts = substitute_change(D = dbh_t, dT = dT,
                              varD = Ddbh_t, WD = wsg, 
                              value = "AGB", cut = c(-0.5, 5), 
                              palms = (Family == "Arecaceae"))),
  size]
```

AGB is then reconstructed from outlier-substituted AGB change, taking the last AGB estimate as a reference. Prior AGB values are estimated by subtracting the cumulative AGB changes between a given year and the last measurement to the last AGB values. This could also be done by taking any other measurement as a reference (e.g. the first one) and reconstructing AGB values based on substituted AGB changes. Reconstructing AGB values allows for values of AGB that are consistent with corrected AGB change values; however this method is prone to systematic bias and we do not recommend using it.  

```{r function-outlier-subs-corr-agb}
reconstruct <- function(x, # variable (must be ordered by increasing year)
                        dx,  # changes in the variable between two censuses
                        ref = 1 # position of the "reference" value of x
) {
  # cumulative sum (omitting NAs)
  cx <- cumsum(ifelse(is.na(dx), 0, dx)) + dx*0
  cx <- c(0, cx[-length(cx)])
  # reconstruct AGB
  y <- x[ref] - cx[ref] + cx
}

data.table::setorder(df_stem, year)
df_stem[, agb_ts := reconstruct(agb_t, Dagb_ts*dT, length(dT)), .(stemID)]
```

```{r ex-outlier-subs-corr-agb, echo = FALSE, fig.cap = "Example of a stem (stemID: 134) with excessive DBH growth. The original (black points) and outlier-corrected (red points) AGB are shown on the y-axis."}
dfcorr <- subset(df_stem, stemID==134)
plot(x = dfcorr$year, y = dfcorr$agb_ts, col = 2, pch = 16, 
     xlab = "Year", ylab = "AGB (Mg)", main = "StemID = 134", 
     ylim = c(13,26))
points(x = dfcorr$year, y = dfcorr$agb_t, pch = 16)
``` 

## Aggregating AGB values 

We first reorganized the stem censuses to a long format with a `variable` column (values: "agb" for AGB or "awp" for AGB changes) and a `method`column for the method used: allometry [@Chave2005 or @Chave2014; with or without the height allometry from @MartinezCano2019]; and correction type (original data with or without taper correction from @Cushman2014; with or without outlier substitution). 

```{r melt-table}
df_stem_melt <-
  data.table::melt(
    df_stem,
    id.vars = c("stemID", "treeID", "census_year", "quadrat", "DFstatus", "size", "sp"), 
    measure.vars = grep("chave|Dagb|agb_", colnames(df_stem)),
    variable.name = "method",
  )

df_stem_melt[, variable := c("agb", "awp")[grepl("Dagb", method) + 1]]
df_stem_melt[grepl("_ts", method), method := "chave14+taper+subs"]
df_stem_melt[grepl("_t", method), method := "chave14+taper"]
df_stem_melt[method == "Dagb", method := "chave14"]

# replace NAs with 0 in agb values
df_stem_melt[is.na(value), value := 0]
```

The last correction applied aims at estimating the plot annual productivity (correcting for unrecorded growth between two censuses), as proposed by @Kohyama2019. 

```{r kohyama-correction}
kohyama_correction <- function(stock, gain, loss, dT, output = "prod") {
  B0 <- stock
  BS0 <- B0 - loss * dT
  BT <- B0 + (gain - loss) * dT
  if (output == "prod") {
    outp <- (log(BT / BS0) * (BT - B0)) / (dT * log(BT / B0))
  } else if (output == "mort"){
    outp <- (log(B0 / BS0) * (BT - B0)) / (dT * log(BT / B0))
  } else 
    stop("Please provide either 'prod' (production) or 'mort' (mortality) as an output.")
  return(outp)
}
```

Below is a function that aggregates AGB and AWP values according to a grouping factor, and applies the ○correction from @Kohyama2019. 

```{r aggr-agb-dyn-function}
aggregate_agb_dyn <- function(group, # grouping factor
                              area,  # unit area
                              kohyama = TRUE, # apply the Kohyama et al 2019 correction?
                              agg_years = FALSE,  # aggregate over years?
                              long = FALSE # give results in long format?
) {
  
  # get long format table with aggregated values 
  df <- df_stem_melt[,  .(value = sum(value) / area),
                     .(variable, year = census_year, group = get(group))]
  
  df <- data.table::dcast(df, year + group ~ variable)
  
  if (kohyama) {
    # apply Kohyama correction 
    # > need to estimate mortality
    df[order(year), `:=` (dT = c(diff(year), NA), 
                          awm = awp - c(diff(agb)/diff(year), NA)), .(group)]
    df[, awp := kohyama_correction(agb, awp, awm, dT)]
  }
  
  # mean across all years
  if (agg_years)
    df <- df[, .(agb = mean(agb), awp = mean(awp, na.rm = TRUE)), .(group)]
  
  if (long) {
    ids <- c("group", "year")[c("group", "year") %in% colnames(df)]
    df <- data.table::melt(df, measure.vars = c("agb", "awp"), id.vars = ids)
  }
  
  colnames(df)[1] <- group
  return(df)
}
```

We first estimated the plot-level annual AGB and AWP for each method used. 

```{r aagr-by-methods}
df_plot <- subset(aggregate_agb_dyn("method", 50, long = TRUE, kohyama = FALSE), !is.na(value))
df_plot_kohyama <- subset(aggregate_agb_dyn("method", 50, long = TRUE), 
                          variable=="awp" & !is.na(value))
df_plot_kohyama[, method := paste0(method, "+kohyama")]

df_plot <- rbind(df_plot, df_plot_kohyama)
```

For all other aggregated AGB data, we used taper-corrected DBHs, the @Chave2014 allometric equation (without height), and applied outlier substitution for AWP but not AGB.   

```{r subset-corrections}
df_stem_melt <- subset(df_stem_melt,
                       (method == "chave14+taper+subs" & variable == "awp") |
                         (method == "chave14+taper" & variable == "agb")
)
```

We also calculated the mean AGB and AWP by size class over all years. 

```{r aggr-by-size}
df_size <- aggregate_agb_dyn(group = "size", area = 50, agg_years = TRUE)
```

To group species into functional groups we used plant functional types as described in @Ruger2020. The data was downloaded from their supplementary material. 

```{r get-ruger-data}
if (!file.exists("ruger_data_s1.xlsx"))
  utils::download.file(url = "https://www.science.org/doi/suppl/10.1126/science.aaz4797/suppl_file/aaz4797_ruger_data_s1.xlsx", 
                       destfile = "ruger_data_s1.xlsx")
# if the function doesn't work the data can be downloaded "manually"

# read downloaded data
ruger_data <- readxl::read_xlsx("ruger_data_s1.xlsx", sheet = "Data")

ruger_data$sp <- tolower(ruger_data$sp)

# change PFT names
ruger_levels <- strsplit("1=slow, 2=fast, 3=LLP, 4=SLB, 5=intermediate", "=|, ")[[1]]
ruger_levels <- data.frame(matrix(ruger_levels, ncol = 2, byrow = TRUE))
colnames(ruger_levels) = c("PFT_2axes", "PFT")

ruger_data <- merge(ruger_data, ruger_levels)
```

*Swartzia simplex* has two subspecies but only one is represented in the data from @Ruger2020. We gave both subspecies the same plant functional type. 

```{r change-swartzia}
swartzia2 <- subset(ruger_data, Genus=="Swartzia")
swartzia2$sp <- "swars2"
ruger_data <- rbind(ruger_data, swartzia2)
``` 

Species plant functional types were then added to the census data, and we calculated the  mean of AGB and AWP across censuses by plant functional type. 

```{r aggr-by-pft}
df_stem_melt <- merge(df_stem_melt, ruger_data[, c("sp", "PFT")], by = "sp", all.x = TRUE)

df_pft <- aggregate_agb_dyn("PFT", 50, agg_years = TRUE)
``` 


## Crown-distributed AGB and AWP

We defined a function (`dist_crowns`) that distributes the aboveground biomass and woody productivity of all trees over their entire crown. The radius of the crown is calculated based on the multi-species crown allometry from @MartinezCano2019. The function first creates a grid of pixels of a given width (here set to 2m) over the entire plot. In order to avoid underestimating the AGB and AWP, the grid also includes pixels outside the plot boundaries where the crowns of trees from within the plot fall. The AGB and AWP of each pixel are then calculated as the sum of the taper-corrected AGB (or taper- and outlier-corrected AWP) of each tree multiplied by the proportion of the tree's crown that is within the pixel. The AGB and AWP of the pixels outside the plot boundaries are then mirrored back into the plot by adding them to the opposite pixels inside the plot boundaries.


```{r dist-crowns}
# get crown distributed aboveground biomass density
dist_crowns <- function(wpix, # height of pixels in m
                        gx, gy, # position of trees in the plot, in m
                        rcrown, # radius of tree crowns
                        values # list of value vectors to be distributed (eg AGB)
) {

  if (!is.list(values) | any(lapply(values, length) != length(gx)))
    stop("`values` should be a list of vectors, each the length of gx, gy and rcrown.")

  # define grid limits, including all pixels in which a tree crown falls
  xmin <- floor(min(gx - rcrown) / wpix) * wpix
  xmax <- ceiling(max(gx + rcrown) / wpix) * wpix
  ymin <- floor(min(gy - rcrown) / wpix) * wpix
  ymax <- ceiling(max(gy + rcrown) / wpix) * wpix

  # create grid
  grid <- expand.grid(x = seq(xmin, xmax - wpix, by = wpix) + (wpix/2),
                      y = seq(ymin, ymax-wpix, by = wpix) + (wpix/2))
  data.table::setDT(grid)
  # give each pixel a unique identifier
  grid$pixID <- 1:nrow(grid)

  # for each pixel, select trees that could be in it (distance between the
  # center of the pixel and the tree is less than the radius of the crown + the
  # distance between the center of the pixel and its corners = sqrt(2)/2*wpix)

  dfpix <-
    grid[, .(stems = which(sqrt((x - gx) ^ 2 + (y - gy) ^ 2) < rcrown + sqrt(2) / 2 * wpix)), .(pixID, x, y)]

  dfpix$rcrown <- rcrown[dfpix$stems]
  dfpix$gx <- gx[dfpix$stems]
  dfpix$gy <- gy[dfpix$stems]

  dfpix[, parea := area_circle_square(x - wpix / 2, y - wpix / 2, wpix, gx, gy, rcrown) /
          (rcrown ^ 2 * pi), .(stems, pixID)]


  # mirror pixels outside the plot back inside the plot

  dfpix[, `:=`(x = abs(1000-abs(1000-x)), y = abs(500-abs(500-y)))]

  # aggregate values per pixel

  dfdist <- unique(dfpix[, c("x", "y")])

  for (i in 1:length(values)) {
    dfpix$value <- values[[i]][dfpix$stems]

    dfdisti <-
      dfpix[, .(value = sum(parea * value, na.rm = TRUE) / (wpix / 100) ^ 2),
          .(x, y)]
    colnames(dfdisti)[3] <- paste0("value", i)

    dfdist <- merge(dfdist, dfdisti, by = c("x", "y"))
  }

  return(dfdist)
}


# area of the intersection of a circle and a rectangle ####

# returns the positive root of intersection of line y = h with circle centered
# at the origin and radius r
section <- function(h, r = 1)
{
  # assert(r >= 0); # assume r is positive, leads to some simplifications in the
  # formula below (can factor out r from the square root)
  return(ifelse(h < r, sqrt(r * r - h * h), 0))
}

# indefinite integral of circle segment
g <- function(x, h, r = 1)
{
  return(.5 * (sqrt(1 - x * x / (r * r)) * x * r + r * r * asin(x / r) - 2 * h * x))
}

# area of intersection of an infinitely tall box with left edge at x0, right
# edge at x1, bottom edge at h and top edge at infinity, with circle centered at
# the origin with radius r
area_inf <- function(x0, x1, h, r)
{
  if (x0 > x1)
    seqinr::swap(x0, x1) # this must be sorted otherwise we get negative area

  s <- section(h, r)
  # integrate the area
  return(g(max(-s, min(s, x1)), h, r) - g(max(-s, min(s, x0)), h, r))
}

# area of the intersection of a square (lower corner coordinates: (x0, y0) and
# width w) with a circle of center cx, cy and radius r

area_circle_square <- function(x0, y0, w, cx, cy, r)
{
  # translate square to have the equivalent of a centered circle
  x1 <- (x0 + w) - cx; x0 <- x0 - cx;
  y1 <- (y0 + w) - cy; y0 <- y0 - cy;

  # area of the intersection of a finite box with a circle centered at the origin with radius r
  if (y0 > y1)
    seqinr::swap(y0, y1)

  if (y0 >= 0) {
    # y1 > y0 >=0

    # area of the lower box minus area of the higher box:
    return(area_inf(x0, x1, y0, r) - area_inf(x0, x1, y1, r))

  } else {
    if (y1 < 0) {

      # the box is completely under, just flip it above (opposite y coordinates)
      return(area_inf(x0, x1, -y1, r) - area_inf(x0, x1, -y0, r))

    } else # the box is both above and below, divide it to two boxes
      return(area_inf(x0, x1, 0, r) - area_inf(x0, x1, -y0, r) +
               area_inf(x0, x1, 0, r) - area_inf(x0, x1, y1, r))
  }
}

dftemp <- df_stem[year==2010, c("stemID", "dbh_t", "gx", "gy", "agb_t", "Dagb_ts")]

# crown allometry from Martinez Cano et al., 2019
dftemp[, rcrown := sqrt((0.57 * dbh_t ^ 1.34)/pi) ]
dftemp[, dbh_t := NULL]

df_crown <- dist_crowns(wpix = 2,
                        gx = dftemp$gx,
                        gy = dftemp$gy,
                        rcrown = dftemp$rcrown,
                        values = list(dftemp$agb_t, dftemp$Dagb_ts))
colnames(df_crown)[3:4] <- c("agb", "awp")
```


```{r save-results, echo = FALSE}
df_ind <- subset(df_stem, stemID %in% c(2031, 3671, 1428))

save(df_plot, df_size, df_pft, df_ind, df_crown, file = "cache.rda")
```

# References